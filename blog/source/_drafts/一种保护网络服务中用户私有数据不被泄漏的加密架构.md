## 背景
今天 [小明](http://weibo.com/itsming) 和我提到，有 [番茄土豆](https://pomotodo.com) 的用户发邮件给我们，问我们作为开发者是否有权限看到用户的私有数据，如番茄描述信息。于是我们意识到，这是当前几乎所有网络服务中都存在的问题：开发者的确有权限看到用户所有私有数据，例如私信，未发表的帖子等等。而如果服务器被黑客「拖库」，数据库泄漏，那么攻击者同样可以获取到这些敏感数据。然后我们就想，是否有一种方案，可以保证开发者无法简单地看到用户的隐私数据，而且在服务器数据库泄漏的情况下，依然可以最大程度地保护用户隐私呢？于是经过和小明几个小时的讨论，得出了下文所述的这样一个加密架构。

## 概要
为了避免在服务器上储存用户的明文隐私数据，我们使用一个密钥来对用户的隐私数据进行对称加密，这个密钥是由用户的明文密码经过特定的散列算法生成的，自始自终只在客户端生成和储存。服务器与客户端之间传输的隐私数据都是经过对称加密的，而且服务器并不知道密钥，解密工作由客户端来执行。在整个过程中，没有任何明文的隐私数据储存或流经服务器。

## 前提条件
因为我们要通过用户的明文密码来生成客户端密钥，所以我们需要保证服务器不能接触到用户的明文密码。具体方案即在用户注册帐号或设置密码时，我们将用户输入的明文密码使用特定算法进行散列，然后传输给服务器，服务器可以将客户端散列过后的密码视作明文密码，再执行后续的服务器散列，然后存入数据库。

接下来我们讨论「特定的散列算法」，因为有彩虹表的存在，对较短的明文进行简单的散列是不安全的。通常的做法是在散列的过程中加入 salt, 我们可以在客户端生成 client-password-salt, 然后在提交请求时将 client-password-salt 一并提交到服务器；在需要登录帐号或验证密码时，客户端先向服务器获取 client-password-salt, 然后对明文密码进行散列，提交散列后的密码，这个散列结果必然是和注册时是相同的。这个过程是可以在牺牲一定可靠性的情况下被简化的，可参见下文「简化模式」一节。

## 核心架构
我们的核心架构是服务器端的数据经过对称密码，只有客户端拥有密钥，加密解密都在客户端完成，明文数据自始至终不储存或流经服务器。

加密的密钥是由用户的明文密码，经过加 salt 生成的，这个 client-key-salt 是不同于前文「前提条件」中提到的那个 client-password-salt 的另外一个 salt. 在每次用户由客户端输入密码登录帐号时，客户端就可以由明文密码和从服务器获取到的 client-key-salt 生成用于加密解密的 client-key.

在由客户端向服务器提交隐私数据时，先用 client-key 对其进行加密，在从服务器获取隐私数据时，先用 client-key 对其解密。

若 client-key 被泄露，那么用户可以通过重置 client-key-salt 来更换 client-key. 在这个过程中，用户的所有隐私数据都必须传输到客户端，解密后用新的 client-key 重新加密。这回使重置 client-key 变成一个非常重量级的操作，在下文的「简化模式」中讨论了如何避免重新加密再解密全部隐私数据。

## 简化模式

## 与 OAuth2 配合使用

## 其他议题

## 局限性
